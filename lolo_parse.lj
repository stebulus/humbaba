{ "comment": "Parse lolo code on stdin and emit lolo-json code on stdout",
  "declarations":
  [ {"func": ["main"], "=": ["putChar", {"str": "a"}]}

  , {"data": "Bool", "=": [["True", 0], ["False", 0]]}

  , {"func": ["boolAnd", "a", "b"], "=":
    {"cased": "a", "of": [["True", "b"], ["False", "a"]]}}

  , {"func": ["boolOr", "a", "b"], "=":
    {"cased": "a", "of": [["True", "a"], ["False", "b"]]}}

  , {"func": ["boolNot", "a"], "=":
    {"cased": "a", "of": [["True", "False"], ["False", "True"]]}}

  , {"data": "List", "=": [["Cons", 2], ["Nil", 0]]}

  , {"data": "Either", "=": [["Left", 1], ["Right", 1]]}

  , {"data": "Maybe", "=": [["Just", 1], ["Nothing", 0]]}

  , {"data": "Tuple2", "=": [["Tuple2", 2]]}

  , {"func": ["id", "x"], "=": "x"}

  , {"func": ["compose", "f", "g", "x"], "=": ["f", ["g", "x"]]}

  , {"func": ["flip", "f", "x", "y"], "=": ["f", "y", "x"]}

  , {"func": ["const", "x", "y"], "=": "x"}

  , {"func": ["lookup", "eq", "tuples", "x"], "=":
    {"cased": "tuples", "of":
      [["Nil", "Nothing"],
       ["Cons", "tuple", "rest",
          {"cased": "tuple", "of":
            [["Tuple2", "key", "value",
              {"cased": ["eq", "key", "x"], "of":
                [["True", ["Just", "value"]],
                 ["False", ["lookup", "eq", "rest", "x"]]]}]]}]]}}

  , {"func": ["foldr", "f", "z", "xs"], "=":
    {"cased": "xs", "of":
      [["Cons", "x", "rest", ["f", "x", ["foldr", "f", "z", "rest"]]],
       ["Nil", "z"]]}}

  , {"func": ["foldl", "f", "z", "xs"], "=":
    {"cased": "xs", "of":
      [["Cons", "x", "rest", ["foldl", "f", ["f", "z", "x"], "rest"]],
       ["Nil", "z"]]}}

  , {"func": ["listEq", "eq", "xs", "ys"], "=":
    {"cased": "xs", "of":
      [["Cons", "x", "xrest",
          {"cased": "ys", "of":
            [["Cons", "y", "yrest",
              ["boolAnd",
                ["eq", "x", "y"],
                ["listEq", "eq", "xrest", "yrest"]]],
             ["Nil", "False"]]}],
       ["Nil",
          {"cased": "ys", "of":
            [["Cons", "_", "_", "False"],
             ["Nil", "True"]]}]]}}

  , {"func": ["charLe", "a", "b"], "=":
    ["intLe", ["charOrd", "a"], ["charOrd", "b"]]}

  , {"func": ["stringEq"], "=": ["listEq", "charEq"]}

  , {"func": ["digits2int", "digits"], "=":
    ["foldl", "digits2intStep", 0, "digits"]}

  , {"func": ["digits2intStep", "acc", "digit"], "=":
    ["intAdd", ["intMul", 10, "acc"], ["digit2int", "digit"]]}

  , {"func": ["digit2int", "c"], "=":
    ["intAdd",
      ["charOrd", "c"],
      ["intMul", -1, ["charOrd", {"str": "0"}]]]}

  , {"data": "Token", "=":
    [["IntLiteral", 1],
     ["CharLiteral", 1],
     ["VarId", 1],
     ["ConId", 1],
     ["Let", 0],
     ["In", 0],
     ["Cased", 0],
     ["Casel", 0],
     ["Of", 0],
     ["Data", 0],
     ["Equals", 0],
     ["Arrow", 0],
     ["LParen", 0],
     ["RParen", 0],
     ["LBrace", 0],
     ["RBrace", 0],
     ["Semicolon", 0],
     ["Pipe", 0]]}

  , {"comments":
      ["data Parser a = Done a | More (Eofed a) (Char -> Peeked a)\n",
       "Represents the state of a parser with eventual result of type a.",
       "Done means the parser doesn't want any more input.",
       "More means it wants to look ahead:",
       "the Eofed field is the result if there's no more input;",
       "the function field computes the result if there is more input.\n",
       "There's no failure state here; parsers can only fail in",
       "reaction to input.  (See pEmpty, for example.)",
       "(Rationale: If there were, say, an Error state here,",
       "then we could represent a parser that requires a character",
       "but then inevitably fails after it receives it:",
       "grumpy = More BadEof (const (Consume Error)).",
       "I don't see a use for grumpy, and it complicates the",
       "intuitive notion of 'accepting' a character, so let's omit it.)",
       "(Counter: grumpy is algebraically nice -- it's a left zero",
       "for <|> -- which suggests it deserves more scrutiny.)"],
     "data": "Parser", "=": [["Done", 1], ["More", 2]]}

  , {"comment": "feed :: Char -> Parser a -> Peeked a",
     "func": ["feed", "c", "parser"], "=":
    {"cased": "parser", "of":
      [["Done", "a", ["Pushback", "a"]],
       ["More", "onEof", "onChar", ["onChar", "c"]]]}}

  , {"comment": "feedEof :: Parser a -> Eofed a",
     "func": ["feedEof", "parser"], "=":
    {"cased": "parser", "of":
      [["Done", "a", ["GoodEof", "a"]],
       ["More", "onEof", "_", "onEof"]]}}

  , {"comments":
      ["data Eofed a = GoodEof a | BadEof\n",
       "Result when (Parser a) sees end of input.",
       "GoodEof means the end of input is accepted;",
       "BadEof means the parse failed."],
     "data": "Eofed", "=": [["GoodEof", 1], ["BadEof", 0]]}

  , {"comments":
      ["data Peeked a = Consume (Parser a) | Pushback a | Fail\n",
       "Result when (Parser a) sees a character.",
       "Consume p means it consumes the character",
       "and the next state of the parser is p.",
       "Pushback a means it doesn't consume the character",
       "but completes its work, producing value a;",
       "the caller should arrange for the character to be presented",
       "to the 'next' parser, whatever that means.  (See pApply.)",
       "Fail means the character is unexpected."],
     "data": "Peeked", "=": [["Consume", 1], ["Pushback", 1], ["Fail", 0]]}

  , {"comment": "<$> for Eofed instance of Functor",
     "func": ["eofedMap", "f", "eof"], "=":
    {"cased": "eof", "of":
      [["GoodEof", "x", ["GoodEof", ["f", "x"]]],
       ["BadEof", "eof"]]}}

  , {"comment": "<*> for Eofed instance of Applicative",
     "func": ["eofedApply", "ef", "ex"], "=":
    {"cased": "ef", "of":
      [["GoodEof", "f",
          {"cased": "ex", "of":
            [["GoodEof", "x", ["GoodEof", ["f", "x"]]],
             ["BadEof", "BadEof"]]}],
       ["BadEof", "BadEof"]]}}

  , {"comment": "<|> for Eofed instance of Alternative",
     "func": ["eofedAlt", "left", "right"], "=":
    {"cased": "left", "of":
      [["GoodEof", "_", "left"],
       ["BadEof", "right"]]}}

  , {"comment": "<$> for Peeked instance of Functor",
     "func": ["peekedMap", "f", "peeked"], "=":
    {"cased": "peeked", "of":
      [["Consume", "p", ["Consume", ["pMap", "f", "p"]]],
       ["Pushback", "a", ["Pushback", ["f", "a"]]],
       ["Fail", "Fail"]]}}

  , {"comment": "<|> for Peeked instance of Alternative",
     "func": ["peekedAlt", "left", "right"], "=":
    {"cased": "left", "of":
      [["Fail", "right"],
       ["Consume", "_", "left"],
       ["Pushback", "_", "left"]]}}

  , {"comment": "<$> for Parser instance of Functor",
     "func": ["pMap", "f", "px"], "=":
    {"cased": "px", "of":
      [["Done", "x", ["Done", ["f", "x"]]],
       ["More", "onEof", "onChar",
          ["More",
            ["eofedMap", "f", "onEof"],
            ["compose", ["peekedMap", "f"], "onChar"]]]]}}

  , {"comment": "pure for Parser instance of Applicative",
     "func": ["pPure", "x"], "=": ["Done", "x"]}

  , {"comment": "<*> for Parser instance of Applicative",
     "func": ["pApply", "pf", "px"], "=":
    {"cased": "pf", "of":
      [["Done", "f", ["pMap", "f", "px"]],
       ["More", "onEof", "onChar",
          ["More",
            ["eofedApply", "onEof", ["feedEof", "px"]],
            ["ppFeedApply", "onChar", "px"]]]]}}

  , {"comment": "ppFeedApply :: (Char -> Peeked (a->b)) -> Parser a -> Char -> Peeked b",
     "func": ["ppFeedApply", "c2peekedf", "parserx", "c"], "=":
    {"cased": ["c2peekedf", "c"], "of":
      [["Consume", "parserf", ["Consume", ["pApply", "parserf", "parserx"]]],
       ["Pushback", "f", ["peekedMap", "f", ["feed", "c", "parserx"]]],
       ["Fail", "Fail"]]}}

  , {"comment": "empty for Parser instance of Applicative",
    "func": ["pEmpty"], "=":
    ["More", "BadEof", ["const", "Fail"]]}

  , {"comments":
      ["<|> for Parser instance of Alternative.",
       "p <|> q is the same as p, unless p fails on the next character,",
       "in which case it's the same as q.",
       "There's only 1 character of lookahead (see comments on Peeked);",
       "if p accepts the first character and fails later,",
       "then p <|> q will fail; it won't backtrack."],
     "func": ["pAlt", "left", "right"], "=":
    {"cased": "left", "of":
      [["Done", "a", "left"],
       ["More", "onEof", "onChar",
          ["More",
            ["eofedAlt", "onEof", ["feedEof", "right"]],
            ["ppFeedAlt", "onChar", "right"]]]]}}

  , {"comment": "ppFeedAlt :: (Char -> Peeked a) -> Parser a -> Char -> Peeked a",
     "func": ["ppFeedAlt", "c2peeked1", "fallback", "c"], "=":
    ["peekedAlt", ["c2peeked1", "c"], ["feed", "c", "fallback"]]}

  , {"comment": "*> for Parser instance of Applicative",
     "func": ["pRight", "left", "right"], "=":
    ["pApply", ["pMap", ["flip", "const"], "left"], "right"]}

  , {"comment": "<* for Parser instance of Applicative",
     "func": ["pLeft", "left", "right"], "=":
    ["pApply", ["pMap", "const", "left"], "right"]}

  , {"comment": "some for Parser instance of Applicative",
     "func": ["pSome", "p"], "=":
    ["pAlt", ["pMany", "p"], ["Done", "Nil"]]}

  , {"comment": "many for Parser instance of Applicative",
     "func": ["pMany", "p"], "=":
    ["pApply", ["pMap", "Cons", "p"], ["pSome", "p"]]}

  , {"comment": "optional :: Parser a -> Parser (Maybe a)",
     "func": ["optional", "p"], "=":
    ["pAlt", ["pMap", "Just", "p"], ["pPure", "Nothing"]]}

  , {"comment": "char :: Char -> Parser Char",
     "func": ["char", "c"], "=": ["require", ["charEq", "c"]]}

  , {"comment": "anyChar :: Parser Char",
     "func": ["anyChar"], "=":
    ["More", "BadEof", ["compose", "Consume", "Done"]]}

  , {"comment": "require :: (Char -> Bool) -> Parser Char",
     "func": ["require", "pred"], "=":
    ["More", "BadEof", ["requirePeek", "pred"]]}

  , {"comment": "requirePeek :: (Char -> Bool) -> Char -> Peeked Char",
     "func": ["requirePeek", "pred", "c"], "=":
    {"cased": ["pred", "c"], "of":
      [["True", ["Consume", ["Done", "c"]]],
       ["False", "Fail"]]}}

  , {"comment": "charBetween :: Char -> Char -> Char -> Bool",
     "func": ["charBetween", "lo", "hi", "c"], "=":
    ["boolAnd", ["charLe", "lo", "c"], ["charLe", "c", "hi"]]}

  , {"comment": "charRange :: Char -> Char -> Parser Char",
     "func": ["charRange", "lo", "hi"], "=":
    ["require", ["charBetween", "lo", "hi"]]}

  , {"comment": "optsign :: Parser Bool",
     "func": ["optsign"], "=":
    ["pAlt",
      ["pRight", ["char", {"str": "-"}],
        ["pPure", "False"]],
      ["pRight", ["optional", ["char", {"str": "+"}]],
        ["pPure", "True"]]]}

  , {"comment": "digit :: Parser Char",
     "func": ["digit"], "=": ["ascDigit"]}

  , {"comment": "ascDigit :: Parser Char",
     "func": ["ascDigit"], "=":
    ["charRange", {"str": "0"}, {"str": "9"}]}

  , {"comment": "natLiteral :: Parser Int",
     "func": ["natLiteral"], "=":
    ["pMap", "digits2int", ["pMany", ["digit"]]]}

  , {"comment": "intLiteral :: Parser Int",
     "func": ["intLiteral"], "=":
    ["pApply", ["pMap", "makeIntLiteral", ["optsign"]], ["natLiteral"]]}

  , {"comment": "makeIntLiteral :: Bool -> Int -> Token",
     "func": ["makeIntLiteral", "sign", "n"], "=":
    ["IntLiteral",
      {"cased": "sign", "of":
        [["True", "n"],
         ["False", ["intMul", -1, "n"]]]}]}

  , {"comment": "charLiteral :: Parser Char",
     "func": ["charLiteral"], "=":
    ["pLeft",
      ["pRight",
        ["char", {"str": "'"}],
        ["pMap", "CharLiteral", ["anyChar"]]],
      ["char", {"str": "'"}]]}

  , {"comment": "ascSmall :: Parser Char",
     "func": ["ascSmall"], "=":
    ["require", "isAscSmall"]}

  , {"comment": "isAscSmall :: Char -> Bool",
     "func": ["isAscSmall", "c"], "=":
    ["boolAnd",
      ["charLe", {"str": "a"}, "c"],
      ["charLe", "c", {"str": "z"}]]}

  , {"comment": "small :: Parser Char",
     "func": ["small"], "=":
    ["pAlt", ["ascSmall"], ["char", {"str": "_"}]]}

  , {"comment": "ascLarge :: Parser Char",
     "func": ["ascLarge"], "=":
    ["require", "isAscLarge"]}

  , {"comment": "isAscLarge :: Char -> Bool",
     "func": ["isAscLarge", "c"], "=":
    ["boolAnd",
      ["charLe", {"str": "A"}, "c"],
      ["charLe", "c", {"str": "Z"}]]}

  , {"comment": "large :: Parser Char",
     "func": ["large"], "=": ["ascLarge"]}

  , {"comment": "identChar :: Parser Char",
     "func": ["identChar"], "=":
    ["pAlt", ["small"],
    ["pAlt", ["large"],
    ["pAlt", ["digit"],
             ["char", {"str": "'"}]]]]}

  , {"comment": "varidOrReserved :: Parser Token",
     "func": ["varidOrReserved"], "=":
    ["pMap", "fixupReserved",
      ["pApply", ["pMap", "Cons", ["small"]], ["pSome", ["identChar"]]]]}

  , {"comment": "reservedWords :: List (Tuple2 String Token)",
     "func": ["reservedWords"], "=":
    ["Cons", ["Tuple2",
      ["Cons", {"str": "l"},
      ["Cons", {"str": "e"},
      ["Cons", {"str": "t"},
      "Nil"]]], "Let"],
    ["Cons", ["Tuple2",
      ["Cons", {"str": "i"},
      ["Cons", {"str": "n"},
      "Nil"]], "In"],
    ["Cons", ["Tuple2",
      ["Cons", {"str": "c"},
      ["Cons", {"str": "a"},
      ["Cons", {"str": "s"},
      ["Cons", {"str": "e"},
      ["Cons", {"str": "d"},
      "Nil"]]]]], "Cased"],
    ["Cons", ["Tuple2",
      ["Cons", {"str": "c"},
      ["Cons", {"str": "a"},
      ["Cons", {"str": "s"},
      ["Cons", {"str": "e"},
      ["Cons", {"str": "l"},
      "Nil"]]]]], "Casel"],
    ["Cons", ["Tuple2",
      ["Cons", {"str": "d"},
      ["Cons", {"str": "a"},
      ["Cons", {"str": "t"},
      ["Cons", {"str": "a"},
      "Nil"]]]], "Data"],
    "Nil"]]]]]}

  , {"comment": "fixupReserved :: String -> Token",
     "func": ["fixupReserved", "ident"], "=":
    {"cased": ["lookup", "stringEq", ["reservedWords"], "ident"], "of":
      [["Nothing", ["VarId", "ident"]],
       ["Just", "x", "x"]]}}

  , {"comment": "conid :: Parser Token",
     "func": ["conid"], "=":
    ["pMap", "ConId",
      ["pApply", ["pMap", "Cons", ["large"]], ["pSome", ["identChar"]]]]}

  , {"comment": "token :: Parser Token",
     "func": ["token"], "=":
    ["pAlt", ["varidOrReserved"],
    ["pAlt", ["conid"],
    ["pAlt", ["intLiteral"],
    ["pAlt", ["charLiteral"],
    ["pAlt", ["pRight", ["char", {"str": "="}], ["pPure", "Equals"]],
    ["pAlt", ["pRight", ["char", {"str": ">"}], ["pPure", "Arrow"]],
    ["pAlt", ["pRight", ["char", {"str": "("}], ["pPure", "LParen"]],
    ["pAlt", ["pRight", ["char", {"str": ")"}], ["pPure", "RParen"]],
    ["pAlt", ["pRight", ["char", {"str": "{"}], ["pPure", "LBrace"]],
    ["pAlt", ["pRight", ["char", {"str": "}"}], ["pPure", "RBrace"]],
    ["pAlt", ["pRight", ["char", {"str": ";"}], ["pPure", "Semicolon"]],
             ["pRight", ["char", {"str": "|"}], ["pPure", "Pipe"]]
    ]]]]]]]]]]]}

  , {"comment": "parseString :: Parser a -> String -> Either Char a",
     "func": ["parseString", "parser", "s"], "=":
    {"cased": "s", "of":
      [["Nil", {"cased": ["feedEof", "parser"], "of":
         [["GoodEof", "a", ["Right", "a"]],
          ["BadEof", ["Left", {"str": "e"}]]]}],
       ["Cons", "c", "cs", {"cased": ["feed", "c", "parser"], "of":
         [["Consume", "p", ["parseString", "p", "cs"]],
          ["Pushback", "a", ["Left", {"str": "p"}]],
          ["Fail", ["Left", {"str": "f"}]]]}]]}}

  ]
}
