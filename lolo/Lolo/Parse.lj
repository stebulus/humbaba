{ "comment": "Parse lolo code on stdin and emit lolo-json code on stdout",
  "declarations":

  [ {"import": "Prim.IO"}
  , {"import": "Prim.Char"}
  , {"import": "Prim.Int"}
  , {"import": "Data.Bool", "as": "B"}
  , {"import": "Data.Function", "as": "F"}
  , {"import": "Data.List", "as": "L"}
  , {"import": "Data.Maybe", "as": "M"}
  , {"import": "Data.Tuple", "as": "T"}
  , {"import": "Data.Unit", "as": "U"}
  , {"import": "Lolo.Digits"}


  , {"comment":



    "### Standard data types and functions ###"



    }

  , {"data": "Either", "=": [["Left", 1], ["Right", 1]]}

  , {"func": ["lookup", "eq", "tuples", "x"], "=":
    {"cased": "tuples", "of":
      [["L.Nil", "M.Nothing"],
       ["L.Cons", "tuple", "rest",
          {"cased": "tuple", "of":
            [["T.Tuple2", "key", "value",
              {"cased": ["eq", "key", "x"], "of":
                [["B.True", ["M.Just", "value"]],
                 ["B.False", ["lookup", "eq", "rest", "x"]]]}]]}]]}}

  , {"func": ["charLe", "a", "b"], "=":
    ["Prim.Int.le", ["Prim.Char.ord", "a"], ["Prim.Char.ord", "b"]]}

  , {"func": ["stringEq"], "=": ["L.eq", "Prim.Char.eq"]}

  , {"func": ["ioThen", "ioa", "iob"], "=":
    ["Prim.IO.bind", "ioa", ["F.const", "iob"]]}

  , {"func": ["sequence_", "ios"], "=":
    ["L.foldr", "ioThen", ["Prim.IO.pure", "U.Unit"], "ios"]}

  , {"func": ["mapM_", "f", "xs"], "=":
    ["sequence_", ["L.map", "f", "xs"]]}

  , {"func": ["putStr", "s"], "=": ["mapM_", "Prim.IO.putChar", "s"]}

  , {"comments":



    [ "### Parsing types ###"



    , "This is standard applicative parsing, except for two things:"
    , "First, we assume only one item of lookahead."
    , "Second, the parser works like an iteratee,"
    , "having data fed to it by the caller."
    ]}

  , {"comments":
      ["data Parser i r = Done r | More (Eofed r) (i -> Peeked i r)\n",
       "Represents the state of a parser with input items of type i",
       "and eventual result of type r.",
       "Done means the parser doesn't want any more input.",
       "More means it wants to look ahead:",
       "the Eofed field is the result if there's no more input;",
       "the function field computes the result if there is more input.\n",
       "There's no failure state here; parsers can only fail in",
       "reaction to input.  (See pEmpty, for example.)",
       "(Rationale: If there were, say, an Error state here,",
       "then we could represent a parser that requires a character",
       "but then inevitably fails after it receives it:",
       "grumpy = More BadEof (const (Consume Error)).",
       "I don't see a use for grumpy, and it complicates the",
       "intuitive notion of 'accepting' a character, so let's omit it.)",
       "(Counter: grumpy is algebraically nice -- it's a left zero",
       "for <|> -- which suggests it deserves more scrutiny.)"],
     "data": "Parser", "=": [["Done", 1], ["More", 2]]}

  , {"comment": "feed :: i -> Parser i r -> Peeked i r",
     "func": ["feed", "i", "parser"], "=":
    {"cased": "parser", "of":
      [["Done", "r", ["Pushback", "r"]],
       ["More", "onEof", "onInput", ["onInput", "i"]]]}}

  , {"comment": "feedEof :: Parser i r -> Eofed r",
     "func": ["feedEof", "parser"], "=":
    {"cased": "parser", "of":
      [["Done", "r", ["GoodEof", "r"]],
       ["More", "onEof", "_", "onEof"]]}}

  , {"comment": "parseList :: Parser i r -> List i -> Either Char r",
     "func": ["parseList", "parser", "s"], "=":
    {"cased": "s", "of":
      [["L.Nil", {"cased": ["feedEof", "parser"], "of":
         [["GoodEof", "r", ["Right", "r"]],
          ["BadEof", ["Left", {"str": "e"}]]]}],
       ["L.Cons", "i", "is", {"cased": ["feed", "i", "parser"], "of":
         [["Consume", "p", ["parseList", "p", "is"]],
          ["Pushback", "r", ["Left", {"str": "p"}]],
          ["Fail", ["Left", {"str": "f"}]]]}]]}}

  , {"comments":
      ["data Eofed r = GoodEof r | BadEof\n",
       "Result when (Parser i r) sees end of input.",
       "GoodEof means the end of input is accepted;",
       "BadEof means the parse failed."],
     "data": "Eofed", "=": [["GoodEof", 1], ["BadEof", 0]]}

  , {"comments":
      ["data Peeked i r = Consume (Parser i r) | Pushback r | Fail\n",
       "Result when (Parser i r) sees an input item.",
       "Consume p means it consumes the input item",
       "and the next state of the parser is p.",
       "Pushback r means it doesn't consume the input item",
       "but completes its work, producing result r;",
       "the caller should arrange for the input item to be presented",
       "to the 'next' parser, whatever that means.  (See pApply.)",
       "Fail means the input item is unexpected."],
     "data": "Peeked", "=": [["Consume", 1], ["Pushback", 1], ["Fail", 0]]}

  , {"comment": "<$> for Eofed instance of Functor",
     "func": ["eofedMap", "f", "eof"], "=":
    {"cased": "eof", "of":
      [["GoodEof", "x", ["GoodEof", ["f", "x"]]],
       ["BadEof", "eof"]]}}

  , {"comment": "<*> for Eofed instance of Applicative",
     "func": ["eofedApply", "ef", "ex"], "=":
    {"cased": "ef", "of":
      [["GoodEof", "f",
          {"cased": "ex", "of":
            [["GoodEof", "x", ["GoodEof", ["f", "x"]]],
             ["BadEof", "BadEof"]]}],
       ["BadEof", "BadEof"]]}}

  , {"comment": "<|> for Eofed instance of Alternative",
     "func": ["eofedAlt", "left", "right"], "=":
    {"cased": "left", "of":
      [["GoodEof", "_", "left"],
       ["BadEof", "right"]]}}

  , {"comment": "<$> for Peeked instance of Functor",
     "func": ["peekedMap", "f", "peeked"], "=":
    {"cased": "peeked", "of":
      [["Consume", "p", ["Consume", ["pMap", "f", "p"]]],
       ["Pushback", "a", ["Pushback", ["f", "a"]]],
       ["Fail", "Fail"]]}}

  , {"comment": "<|> for Peeked instance of Alternative",
     "func": ["peekedAlt", "left", "right"], "=":
    {"cased": "left", "of":
      [["Fail", "right"],
       ["Consume", "_", "left"],
       ["Pushback", "_", "left"]]}}

  , {"comment": "<$> for Parser instance of Functor",
     "func": ["pMap", "f", "px"], "=":
    {"cased": "px", "of":
      [["Done", "x", ["Done", ["f", "x"]]],
       ["More", "onEof", "onChar",
          ["More",
            ["eofedMap", "f", "onEof"],
            ["F.compose", ["peekedMap", "f"], "onChar"]]]]}}

  , {"comment": "pure for Parser instance of Applicative",
     "func": ["pPure", "x"], "=": ["Done", "x"]}

  , {"comment": "<*> for Parser instance of Applicative",
     "func": ["pApply", "pf", "px"], "=":
    {"cased": "pf", "of":
      [["Done", "f", ["pMap", "f", "px"]],
       ["More", "onEof", "onChar",
          ["More",
            ["eofedApply", "onEof", ["feedEof", "px"]],
            ["ppFeedApply", "onChar", "px"]]]]}}

  , {"comment": "ppFeedApply :: (i -> Peeked i (a->b)) -> Parser i a -> i -> Peeked i b",
     "func": ["ppFeedApply", "i2peekedf", "parserx", "i"], "=":
    {"cased": ["i2peekedf", "i"], "of":
      [["Consume", "parserf", ["Consume", ["pApply", "parserf", "parserx"]]],
       ["Pushback", "f", ["peekedMap", "f", ["feed", "i", "parserx"]]],
       ["Fail", "Fail"]]}}

  , {"comment": "empty for Parser instance of Applicative",
    "func": ["pEmpty"], "=":
    ["More", "BadEof", ["F.const", "Fail"]]}

  , {"comments":
      ["<|> for Parser instance of Alternative.",
       "p <|> q is the same as p, unless p fails on the next input item,",
       "in which case it's the same as q.",
       "There's only 1 input item of lookahead (see comments on Peeked);",
       "if p accepts the first input item and fails later,",
       "then p <|> q will fail; it won't backtrack."],
     "func": ["pAlt", "left", "right"], "=":
    {"cased": "left", "of":
      [["Done", "a", "left"],
       ["More", "onEof", "onInput",
          ["More",
            ["eofedAlt", "onEof", ["feedEof", "right"]],
            ["ppFeedAlt", "onInput", "right"]]]]}}

  , {"comment": "ppFeedAlt :: (i -> Peeked i a) -> Parser i a -> i -> Peeked i a",
     "func": ["ppFeedAlt", "i2peeked1", "fallback", "i"], "=":
    ["peekedAlt", ["i2peeked1", "i"], ["feed", "i", "fallback"]]}

  , {"comment": "*> for Parser instance of Applicative",
     "func": ["pRight", "left", "right"], "=":
    ["pApply", ["pMap", ["F.flip", "F.const"], "left"], "right"]}

  , {"comment": "<* for Parser instance of Applicative",
     "func": ["pLeft", "left", "right"], "=":
    ["pApply", ["pMap", "F.const", "left"], "right"]}

  , {"comment": "some for Parser instance of Applicative",
     "func": ["pSome", "p"], "=":
    ["pAlt", ["pMany", "p"], ["Done", "L.Nil"]]}

  , {"comment": "many for Parser instance of Applicative",
     "func": ["pMany", "p"], "=":
    ["pApply", ["pMap", "L.Cons", "p"], ["pSome", "p"]]}

  , {"comment":



    "### Parsing combinators ###"



    }

  , {"comment": "item :: Parser a a",
     "func": ["item"], "=":
    ["More", "BadEof", ["F.compose", "Consume", "Done"]]}

  , {"comment": "optional :: Parser i a -> Parser i (Maybe a)",
     "func": ["optional", "p"], "=":
    ["pAlt", ["pMap", "M.Just", "p"], ["pPure", "M.Nothing"]]}

  , {"comment": "require :: (a -> Bool) -> Parser a a",
     "func": ["require", "pred"], "=":
    ["More", "BadEof", ["requirePeek", "pred"]]}

  , {"comment": "requirePeek :: (a -> Bool) -> a -> Peeked a a",
     "func": ["requirePeek", "pred", "a"], "=":
    {"cased": ["pred", "a"], "of":
      [["B.True", ["Consume", ["Done", "a"]]],
       ["B.False", "Fail"]]}}

  , {"comment": "ignore :: Parser i r -> Parser i Unit",
     "func": ["ignore", "p"], "=": ["pRight", "p", ["Done", "U.Unit"]]}

  , {"comment": "ignoreSome :: Parser i r -> Parser i Unit",
     "func": ["ignoreSome", "p"], "=":
    ["pAlt", ["pRight", "p", ["ignoreSome", "p"]], ["Done", "U.Unit"]]}

  , {"comment": "ignoreUntil :: Parser i r -> Parser i r",
     "func": ["ignoreUntil", "p"], "=":
    ["pAlt", "p", ["pRight", "item", ["ignoreUntil", "p"]]]}

  , {"comment": "delimitedList :: Parser i d -> Parser i a -> Parser i (List a)",
     "func": ["delimitedList", "delimiter", "p"], "=":
    ["pApply",
      ["pMap", "L.Cons", "p"],
      ["pSome", ["pRight", "delimiter", "p"]]]}

  , {"comment": "char :: Char -> Parser Char Char",
     "func": ["char", "c"], "=": ["require", ["Prim.Char.eq", "c"]]}

  , {"comment": "charBetween :: Char -> Char -> Char -> Bool",
     "func": ["charBetween", "lo", "hi", "c"], "=":
    ["B.and", ["charLe", "lo", "c"], ["charLe", "c", "hi"]]}

  , {"comment": "charRange :: Char -> Char -> Parser Char Char",
     "func": ["charRange", "lo", "hi"], "=":
    ["require", ["charBetween", "lo", "hi"]]}

  , {"comments":



    [ "### Lexical structure ###"



    , "Since there's only one item of lookahead,"
    , "we parse in two layers:"
    , "scanning with (Parser Char a), in this section,"
    , "and parsing proper with (Parser Token a), later."
    ]}

  , {"data": "Token", "=":
    [["IntLiteral", 1],
     ["CharLiteral", 1],
     ["VarId", 1],
     ["ConId", 1],
     ["Let", 0],
     ["In", 0],
     ["Cased", 0],
     ["Casei", 0],
     ["Casec", 0],
     ["Of", 0],
     ["Data", 0],
     ["Equals", 0],
     ["Arrow", 0],
     ["LParen", 0],
     ["RParen", 0],
     ["LBrace", 0],
     ["RBrace", 0],
     ["Semicolon", 0],
     ["Pipe", 0]]}

  , {"func": ["tokenEq", "a", "b"], "=":
    {"cased": "a", "of":
      [["IntLiteral", "n",
          {"cased": "b", "of":
            [["IntLiteral", "m", ["intEq", "m", "n"]],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["CharLiteral", "c",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "d", ["intEq", "c", "d"]],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["VarId", "ident",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "ident2", ["stringEq", "ident", "ident2"]],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["ConId", "ident",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "ident2", ["stringEq", "ident", "ident2"]],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["Let",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.True"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["In",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.True"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["Cased",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.True"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["Casei",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.True"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["Casec",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.True"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["Of",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.True"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["Data",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.True"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["Equals",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.True"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["Arrow",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.True"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["LParen",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.True"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["RParen",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.True"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["LBrace",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.True"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["RBrace",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.True"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.False"]]}
          ],
       ["Semicolon",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.True"],
             ["Pipe", "B.False"]]}
          ],
       ["Pipe",
          {"cased": "b", "of":
            [["IntLiteral", "_", "B.False"],
             ["CharLiteral", "_", "B.False"],
             ["VarId", "_", "B.False"],
             ["ConId", "_", "B.False"],
             ["Let", "B.False"],
             ["In", "B.False"],
             ["Cased", "B.False"],
             ["Casei", "B.False"],
             ["Casec", "B.False"],
             ["Of", "B.False"],
             ["Data", "B.False"],
             ["Equals", "B.False"],
             ["Arrow", "B.False"],
             ["LParen", "B.False"],
             ["RParen", "B.False"],
             ["LBrace", "B.False"],
             ["RBrace", "B.False"],
             ["Semicolon", "B.False"],
             ["Pipe", "B.True"]]}
          ]]}}

  , {"comment": "optsign :: Parser Char Bool",
     "func": ["optsign"], "=":
    ["pAlt",
      ["pRight", ["char", {"str": "-"}],
        ["pPure", "B.False"]],
      ["pRight", ["optional", ["char", {"str": "+"}]],
        ["pPure", "B.True"]]]}

  , {"comment": "digit :: Parser Char Char",
     "func": ["digit"], "=": "ascDigit"}

  , {"comment": "ascDigit :: Parser Char Char",
     "func": ["ascDigit"], "=":
    ["charRange", {"str": "0"}, {"str": "9"}]}

  , {"comment": "natLiteral :: Parser Char Int",
     "func": ["natLiteral"], "=":
    ["pMap", "Lolo.Digits.readInt", ["pMany", "digit"]]}

  , {"comment": "intLiteral :: Parser Char Int",
     "func": ["intLiteral"], "=":
    ["pApply", ["pMap", "makeIntLiteral", "optsign"], "natLiteral"]}

  , {"comment": "makeIntLiteral :: Bool -> Int -> Token",
     "func": ["makeIntLiteral", "sign", "n"], "=":
    ["IntLiteral",
      {"cased": "sign", "of":
        [["B.True", "n"],
         ["B.False", ["Prim.Int.mul", -1, "n"]]]}]}

  , {"comment": "charLiteral :: Parser Char Char",
     "func": ["charLiteral"], "=":
    ["pLeft",
      ["pRight",
        ["char", {"str": "'"}],
        ["pMap", "CharLiteral", "item"]],
      ["char", {"str": "'"}]]}

  , {"comment": "ascSmall :: Parser Char Char",
     "func": ["ascSmall"], "=":
    ["require", "isAscSmall"]}

  , {"comment": "isAscSmall :: Char -> Bool",
     "func": ["isAscSmall"], "=":
    ["charBetween", {"str": "a"}, {"str": "z"}]}

  , {"comment": "small :: Parser Char Char",
     "func": ["small"], "=":
    ["pAlt", "ascSmall", ["char", {"str": "_"}]]}

  , {"comment": "ascLarge :: Parser Char Char",
     "func": ["ascLarge"], "=":
    ["require", "isAscLarge"]}

  , {"comment": "isAscLarge :: Char -> Bool",
     "func": ["isAscLarge"], "=":
    ["charBetween", {"str": "A"}, {"str": "Z"}]}

  , {"comment": "large :: Parser Char Char",
     "func": ["large"], "=": "ascLarge"}

  , {"comment": "newline :: Parser Char Unit",
     "func": ["newline"], "=":
    ["pRight",
      ["pAlt",
        ["pLeft",
          ["char", {"str": "\r"}],
          ["optional", ["char", {"str": "\n"}]]],
      ["pAlt",
        ["char", {"str": "\n"}],
        ["char", {"str": "\f"}]]],
      ["Done", "U.Unit"]]}

  , {"comment": "whitechar :: Parser Char Char",
     "func": ["whitechar"], "=": "ascWhitechar"}

  , {"comment": "ascWhitechar :: Parser Char Char",
     "func": ["ascWhitechar"], "=":
    ["pAlt", ["char", {"str": " "}],
    ["pAlt", ["char", {"str": "\t"}],
    ["pAlt", "newline",
             ["char", {"str": "\u000B"}]]]]}

  , {"comment": "comment :: Parser Char Unit",
     "func": ["comment"], "=":
     ["pRight", ["char", {"str": "#"}], ["ignoreUntil", "newline"]]}

  , {"comment": "whitestuff :: Parser Char Unit",
     "func": ["whitestuff"], "=":
    ["pAlt", ["ignore", "whitechar"], "comment"]}

  , {"comment": "identChar :: Parser Char Char",
     "func": ["identChar"], "=":
    ["pAlt", "small", ["pAlt", "large", "digit"]]}

  , {"comment": "varidOrReserved :: Parser Char Token",
     "func": ["varidOrReserved"], "=":
    ["pMap", "fixupReserved",
      ["pApply", ["pMap", "L.Cons", "small"], ["pSome", "identChar"]]]}

  , {"comment": "reservedWords :: List (T.Tuple2 String Token)",
     "func": ["reservedWords"], "=":
    ["L.Cons", ["T.Tuple2",
      ["L.Cons", {"str": "l"},
      ["L.Cons", {"str": "e"},
      ["L.Cons", {"str": "t"},
      "L.Nil"]]], "Let"],
    ["L.Cons", ["T.Tuple2",
      ["L.Cons", {"str": "i"},
      ["L.Cons", {"str": "n"},
      "L.Nil"]], "In"],
    ["L.Cons", ["T.Tuple2",
      ["L.Cons", {"str": "c"},
      ["L.Cons", {"str": "a"},
      ["L.Cons", {"str": "s"},
      ["L.Cons", {"str": "e"},
      ["L.Cons", {"str": "d"},
      "L.Nil"]]]]], "Cased"],
    ["L.Cons", ["T.Tuple2",
      ["L.Cons", {"str": "c"},
      ["L.Cons", {"str": "a"},
      ["L.Cons", {"str": "s"},
      ["L.Cons", {"str": "e"},
      ["L.Cons", {"str": "i"},
      "L.Nil"]]]]], "Casei"],
    ["L.Cons", ["T.Tuple2",
      ["L.Cons", {"str": "c"},
      ["L.Cons", {"str": "a"},
      ["L.Cons", {"str": "s"},
      ["L.Cons", {"str": "e"},
      ["L.Cons", {"str": "c"},
      "L.Nil"]]]]], "Casec"],
    ["L.Cons", ["T.Tuple2",
      ["L.Cons", {"str": "o"},
      ["L.Cons", {"str": "f"},
      "L.Nil"]], "Of"],
    ["L.Cons", ["T.Tuple2",
      ["L.Cons", {"str": "d"},
      ["L.Cons", {"str": "a"},
      ["L.Cons", {"str": "t"},
      ["L.Cons", {"str": "a"},
      "L.Nil"]]]], "Data"],
    "L.Nil"]]]]]]]}

  , {"comment": "fixupReserved :: String -> Token",
     "func": ["fixupReserved", "ident"], "=":
    {"cased": ["lookup", "stringEq", "reservedWords", "ident"], "of":
      [["M.Nothing", ["VarId", "ident"]],
       ["M.Just", "x", "x"]]}}

  , {"comment": "conid :: Parser Char Token",
     "func": ["conid"], "=":
    ["pMap", "ConId",
      ["pApply", ["pMap", "L.Cons", "large"], ["pSome", "identChar"]]]}

  , {"comments":
      [ "token :: Parser Char Token\n"
      , "Haskell '->' is here reduced to '>', to avoid ambiguity:"
      , "in Lolo, '-' can only be the start of an integer literal."
      ],
     "func": ["token"], "=":
    ["pAlt", "varidOrReserved",
    ["pAlt", "conid",
    ["pAlt", "intLiteral",
    ["pAlt", "charLiteral",
    ["pAlt", ["pRight", ["char", {"str": "="}], ["pPure", "Equals"]],
    ["pAlt", ["pRight", ["char", {"str": ">"}], ["pPure", "Arrow"]],
    ["pAlt", ["pRight", ["char", {"str": "("}], ["pPure", "LParen"]],
    ["pAlt", ["pRight", ["char", {"str": ")"}], ["pPure", "RParen"]],
    ["pAlt", ["pRight", ["char", {"str": "{"}], ["pPure", "LBrace"]],
    ["pAlt", ["pRight", ["char", {"str": "}"}], ["pPure", "RBrace"]],
    ["pAlt", ["pRight", ["char", {"str": ";"}], ["pPure", "Semicolon"]],
             ["pRight", ["char", {"str": "|"}], ["pPure", "Pipe"]]
    ]]]]]]]]]]]}

  , {"comment": "ignoreWhitespace :: Parser Char Unit",
     "func": ["ignoreWhitespace"], "=": ["ignoreSome", "whitestuff"]}

  , {"comment": "tokenInWhitespace :: Parser Char Token",
     "func": ["tokenInWhitespace"], "=":
    ["pLeft",
      ["pRight", "ignoreWhitespace", "token"],
      "ignoreWhitespace"]}

  , {"comment":



    "### Common syntactical constructions ###"



    }

  , {"comment": "inBraces :: Parser Token a -> Parser Token a",
     "func": ["inBraces", "p"], "=":
    ["pRight", ["require", ["tokenEq", "LBrace"]],
      ["pLeft", "p", ["require", ["tokenEq", "RBrace"]]]]}

  , {"comment": "bracedList :: Parser Token a -> Parser Token (List a)",
     "func": ["bracedList", "p"], "=":
    ["inBraces",
      ["delimitedList", ["require", ["tokenEq", "Semicolon"]], "p"]]}

  , {"comment":



    "### Expressions ###"



    }

  , {"comments":
      ["data Exp = LetExp (List Binding) Exp\n",
       "         | CasedExp Exp (List DAlt)\n",
       "         | CaseiExp Exp (List IAlt)\n",
       "         | CasecExp Exp (List CAlt)\n",
       "         | FExp (List AExp)\n"],
    "data": "Exp", "=":
    [["LetExp", 2],
     ["CasedExp", 2],
     ["CaseiExp", 2],
     ["CasecExp", 2],
     ["FExp", 1]]}

  , {"comment": "exp :: Parser Token Exp",
     "func": ["exp"], "=":
    ["pAlt", "letExp",
    ["pAlt", "casedExp",
    ["pAlt", "caseiExp",
    ["pAlt", "casecExp",
             "fExp"]]]]}

  , {"comment": "data Binding = Binding String Exp",
     "data": "Binding", "=": [["Binding", 2]]}

  , {"comment": "varidString :: Parser Token String",
     "func": ["varidString"], "=":
    ["More", "BadEof", "varidStringPeek"]}

  , {"comment": "varidStringPeek :: Token -> Peeked Token String",
     "func": ["varidStringPeek", "token"], "=":
    {"cased": "token", "of":
      [["IntLiteral", "_", "Fail"],
       ["CharLiteral", "_", "Fail"],
       ["VarId", "s", ["Consume", ["Done", "s"]]],
       ["ConId", "_", "Fail"],
       ["Let", "Fail"],
       ["In", "Fail"],
       ["Cased", "Fail"],
       ["Casei", "Fail"],
       ["Casec", "Fail"],
       ["Of", "Fail"],
       ["Data", "Fail"],
       ["Equals", "Fail"],
       ["Arrow", "Fail"],
       ["LParen", "Fail"],
       ["RParen", "Fail"],
       ["LBrace", "Fail"],
       ["RBrace", "Fail"],
       ["Semicolon", "Fail"],
       ["Pipe", "Fail"]]}}

  , {"comment": "binding :: Parser Token Binding",
     "func": ["binding"], "=":
    ["pApply",
      ["pMap", "Binding", "varidString"],
      ["pRight", ["require", ["tokenEq", "Equals"]], "exp"]]}

  , {"comment": "letExp :: Parser Token Exp",
     "func": ["letExp"], "=":
    ["pApply",
      ["pApply",
        ["pRight", ["require", ["tokenEq", "Let"]], ["pPure", "LetExp"]],
        ["bracedList", "binding"]],
      ["pRight",
        ["require", ["tokenEq", "In"]],
        "exp"]]}

  , {"comment": "casedExp :: Parser Token Exp",
     "func": ["casedExp"], "=":
    ["pApply",
      ["pApply",
        ["pRight",
          ["require", ["tokenEq", "Cased"]],
          ["pPure", "CasedExp"]],
        "exp"],
      ["pRight",
        ["require", ["tokenEq", "Of"]],
        ["bracedList", "dalt"]]]}

  , {"comment": "data DAlt = DAlt String (List String) Exp",
     "data": "DAlt", "=": [["DAlt", 3]]}

  , {"comment": "dalt :: Parser Token DAlt",
     "func": ["dalt"], "=":
    ["pApply",
      ["pApply",
        ["pMap", "DAlt", "conidString"],
        ["pSome", "varidString"]],
      ["pRight", ["require", ["tokenEq", "Arrow"]],
        "exp"]]}

  , {"comment": "conidString :: Parser Token String",
     "func": ["conidString"], "=":
    ["More", "BadEof", "conidStringPeek"]}

  , {"comment": "conidStringPeek :: Token -> Peeked Token String",
     "func": ["conidStringPeek", "token"], "=":
    {"cased": "token", "of":
      [["IntLiteral", "_", "Fail"],
       ["CharLiteral", "_", "Fail"],
       ["VarId", "_", "Fail"],
       ["ConId", "s", ["Consume", ["Done", "s"]]],
       ["Let", "Fail"],
       ["In", "Fail"],
       ["Cased", "Fail"],
       ["Casei", "Fail"],
       ["Casec", "Fail"],
       ["Of", "Fail"],
       ["Data", "Fail"],
       ["Equals", "Fail"],
       ["Arrow", "Fail"],
       ["LParen", "Fail"],
       ["RParen", "Fail"],
       ["LBrace", "Fail"],
       ["RBrace", "Fail"],
       ["Semicolon", "Fail"],
       ["Pipe", "Fail"]]}}

  , {"comment": "caseiExp :: Parser Token Exp",
     "func": ["caseiExp"], "=":
    ["pApply",
      ["pApply",
        ["pRight",
          ["require", ["tokenEq", "Casei"]],
          ["pPure", "CaseiExp"]],
        "exp"],
      ["pRight",
        ["require", ["tokenEq", "Of"]],
        ["bracedList", "ialt"]]]}

  , {"comment": "data IAlt = IAltInt Int Exp | IAltVar String Exp",
     "data": "IAlt", "=": [["IAltInt", 2], ["IAltVar", 2]]}

  , {"comment": "ialt :: Parser Token IAlt",
     "func": ["ialt"], "=": ["pAlt", "ialtInt", "ialtVar"]}

  , {"comment": "ialtInt :: Parser Token IAlt",
     "func": ["ialtInt"], "=":
    ["pApply",
      ["pMap", "IAltInt", "intFromLiteral"],
      ["pRight", ["require", ["tokenEq", "Arrow"]], "exp"]]}

  , {"comment": "ialtVar :: Parser Token IAlt",
     "func": ["ialtVar"], "=":
    ["pApply",
      ["pMap", "IAltVar", "varidString"],
      ["pRight", ["require", ["tokenEq", "Arrow"]], "exp"]]}

  , {"comment": "intFromLiteral :: Parser Token Int",
     "func": ["intFromLiteral"], "=":
    ["More", "BadEof", "intFromLiteralPeek"]}

  , {"comment": "intFromLiteralPeek :: Token -> Peeked Token Int",
     "func": ["intFromLiteralPeek", "token"], "=":
    {"cased": "token", "of":
      [["IntLiteral", "n", ["Consume", ["Done", "n"]]],
       ["CharLiteral", "_", "Fail"],
       ["VarId", "_", "Fail"],
       ["ConId", "_", "Fail"],
       ["Let", "Fail"],
       ["In", "Fail"],
       ["Cased", "Fail"],
       ["Casei", "Fail"],
       ["Casec", "Fail"],
       ["Of", "Fail"],
       ["Data", "Fail"],
       ["Equals", "Fail"],
       ["Arrow", "Fail"],
       ["LParen", "Fail"],
       ["RParen", "Fail"],
       ["LBrace", "Fail"],
       ["RBrace", "Fail"],
       ["Semicolon", "Fail"],
       ["Pipe", "Fail"]]}}

  , {"comment": "casecExp :: Parser Token Exp",
     "func": ["casecExp"], "=":
    ["pApply",
      ["pApply",
        ["pRight",
          ["require", ["tokenEq", "Casec"]],
          ["pPure", "CasecExp"]],
        "exp"],
      ["pRight",
        ["require", ["tokenEq", "Of"]],
        ["bracedList", "calt"]]]}

  , {"comment": "data CAlt = CAltChar Char Exp | CAltVar String Exp",
     "data": "CAlt", "=": [["CAltChar", 2], ["CAltVar", 2]]}

  , {"comment": "calt :: Parser Token CAlt",
     "func": ["calt"], "=": ["pAlt", "caltChar", "caltVar"]}

  , {"comment": "caltChar :: Parser Token CAlt",
     "func": ["caltChar"], "=":
    ["pApply",
      ["pMap", "CAltChar", "charFromLiteral"],
      ["pRight", ["require", ["tokenEq", "Arrow"]], "exp"]]}

  , {"comment": "caltVar :: Parser Token CAlt",
     "func": ["caltVar"], "=":
    ["pApply",
      ["pMap", "CAltVar", "varidString"],
      ["pRight", ["require", ["tokenEq", "Arrow"]], "exp"]]}

  , {"comment": "charFromLiteral :: Parser Token Char",
     "func": ["charFromLiteral"], "=":
    ["More", "BadEof", "charFromLiteralPeek"]}

  , {"comment": "charFromLiteralPeek :: Token -> Peeked Token Char",
     "func": ["charFromLiteralPeek", "token"], "=":
    {"cased": "token", "of":
      [["IntLiteral", "_", "Fail"],
       ["CharLiteral", "c", ["Consume", ["Done", "c"]]],
       ["VarId", "_", "Fail"],
       ["ConId", "_", "Fail"],
       ["Let", "Fail"],
       ["In", "Fail"],
       ["Cased", "Fail"],
       ["Casei", "Fail"],
       ["Casec", "Fail"],
       ["Of", "Fail"],
       ["Data", "Fail"],
       ["Equals", "Fail"],
       ["Arrow", "Fail"],
       ["LParen", "Fail"],
       ["RParen", "Fail"],
       ["LBrace", "Fail"],
       ["RBrace", "Fail"],
       ["Semicolon", "Fail"],
       ["Pipe", "Fail"]]}}

  , {"comment": "fExp :: Parser Token Exp",
     "func": ["fExp"], "=": ["pMap", "FExp", ["pMany", "aExp"]]}

  , {"comments":
      ["data AExp = AChar Char\n",
       "          | AInt Int\n",
       "          | AVar String\n",
       "          | ACon String\n",
       "          | ASub Exp"],
     "data": "AExp", "=":
     [["AChar", 1],
      ["AInt", 1],
      ["AVar", 1],
      ["ACon", 1],
      ["ASub", 1]]}

  , {"comment": "aExp :: Parser Token AExp",
     "func": ["aExp"], "=": ["More", "BadEof", "aExpPeek"]}

  , {"comment": "aExpPeek :: Token -> Peeked Token AExp",
     "func": ["aExpPeek", "token"], "=":
    {"cased": "token", "of":
      [["IntLiteral", "n", ["Consume", ["Done", ["AInt", "n"]]]],
       ["CharLiteral", "c", ["Consume", ["Done", ["AChar", "c"]]]],
       ["VarId", "s", ["Consume", ["Done", ["AVar", "s"]]]],
       ["ConId", "s", ["Consume", ["Done", ["ACon", "s"]]]],
       ["Let", "Fail"],
       ["In", "Fail"],
       ["Cased", "Fail"],
       ["Casei", "Fail"],
       ["Casec", "Fail"],
       ["Of", "Fail"],
       ["Data", "Fail"],
       ["Equals", "Fail"],
       ["Arrow", "Fail"],
       ["LParen", ["Consume",
          ["pMap", "ASub",
            ["pLeft", "exp", ["require", ["tokenEq", "RParen"]]]]]],
       ["RParen", "Fail"],
       ["LBrace", "Fail"],
       ["RBrace", "Fail"],
       ["Semicolon", "Fail"],
       ["Pipe", "Fail"]]}}

  , {"comment":



    "### Declarations ###"



    }

  , {"comments":
      ["data Decl = DataDecl String (List ConDecl) \n",
       "          | FuncDecl String (List String) Exp\n"],
     "data": "Decl", "=": [["DataDecl", 2], ["FuncDecl", 3]]}

  , {"comment": "decl :: Parser Token Decl",
     "func": ["decl"], "=":
    ["pAlt", "dataDecl", "funcDecl"]}

  , {"comment": "dataDecl :: Parser Token Decl",
     "func": ["dataDecl"], "=":
    ["pApply",
      ["pApply",
        ["pRight",
          ["require", ["tokenEq", "Data"]],
          ["pPure", "DataDecl"]],
        "conidString"],
      ["pRight",
        ["require", ["tokenEq", "Equals"]],
        ["delimitedList",
          ["require", ["tokenEq", "Pipe"]],
          "conDecl"]]]}

  , {"comment": "data ConDecl = ConDecl String Int",
     "data": "ConDecl", "=": [["ConDecl", 2]]}

  , {"comment": "conDecl :: Parser Token ConDecl",
     "func": ["conDecl"], "=":
    ["pApply",
      ["pMap", "ConDecl", "conidString"],
      "intFromLiteral"]}

  , {"comment": "funcDecl :: Parser Token Decl",
     "func": ["funcDecl"], "=":
    ["pApply",
      ["pApply",
        ["pMap", "FuncDecl", "varidString"],
        ["pSome", "varidString"]],
      ["pRight",
        ["require", ["tokenEq", "Equals"]],
        "exp"]]}

  , {"comment": "program :: Parser Token (List Decl)",
     "func": ["program"], "=": ["bracedList", "decl"]}

  , {"comment":



    "### Parsing stdin ###"



    }

  , {"comment": "parseStdin :: IO (Either Char (List Decl))",
     "func": ["parseStdin"], "=":
    ["parseStdinHelper", "tokenInWhitespace", "program"]}

  , {"comment": "parseStdinHelper :: Parser Char Token -> Parser Token a -> IO (Either Char a)",
     "func": ["parseStdinHelper", "charstate", "tokenstate"], "=":
    ["Prim.IO.bind", "Prim.IO.isEOF",
      ["parseStdinLoop", "charstate", "tokenstate"]]}

  , {"comment": "parseStdinLoop :: Parser Char Token -> Parser Token a -> Bool -> IO (Either Char a)",
     "func": ["parseStdinLoop", "charstate", "tokenstate", "eof"], "=":
    {"cased": "eof", "of":
      [["B.True", {"cased": ["feedEof", "charstate"], "of":
        [["GoodEof", "token",
          {"cased": ["feed", "token", "tokenstate"], "of":
            [["Consume", "tokenstate2",
              {"cased": ["feedEof", "tokenstate2"], "of":
                [["GoodEof", "r", ["Prim.IO.pure", ["Right", "r"]]],
                 ["BadEof", ["Prim.IO.pure", ["Left", {"str": "e"}]]]]}],
             ["Pushback", "_", ["Prim.IO.pure", ["Left", {"str": "p"}]]],
             ["Fail", ["Prim.IO.pure", ["Left", {"str": "f"}]]]]}],
         ["BadEof", ["Prim.IO.pure", ["Left", {"str": "e"}]]]]}],
       ["B.False", ["Prim.IO.bind", "Prim.IO.getChar",
        ["parseStdinLoopChar", "charstate", "tokenstate"]]]]}}

  , {"comment": "parseStdinLoopChar :: Parser Char Token -> Parser Token a -> Char -> IO (Either Char a)",
     "func": ["parseStdinLoopChar", "charstate", "tokenstate", "c"], "=":
    {"cased": ["feed", "c", "charstate"], "of":
      [["Consume", "charstate2",
        ["Prim.IO.bind", "Prim.IO.isEOF",
          ["parseStdinLoop", "charstate2", "tokenstate"]]],
       ["Pushback", "token",
          {"cased": ["feed", "token", "tokenstate"], "of":
            [["Consume", "tokenstate2",
                ["parseStdinLoopChar", "tokenInWhitespace",
                  "tokenstate2", "c"]],
             ["Pushback", "_", ["Prim.IO.pure", ["Left", {"str": "p"}]]],
             ["Fail", ["Prim.IO.pure", ["Left", {"str": "f"}]]]]}],
       ["Fail", ["Prim.IO.pure", ["Left", {"str": "f"}]]]]}}

  , {"comment":



    "### Emitting JSON representation ###"



    }

  , {"func": ["emitArray", "itemEmitters"], "=":
    ["ioThen",
      ["Prim.IO.putChar", {"str": "["}],
      ["ioThen",
        ["sequence_",
          ["L.intersperse",
            ["Prim.IO.putChar", {"str": ","}],
            "itemEmitters"]],
        ["Prim.IO.putChar", {"str": "]"}]]]}

  , {"func": ["emitStr", "s"], "=":
    ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
    ["ioThen", ["mapM_", "emitStrChar", "s"],
               ["Prim.IO.putChar", {"str": "\""}]]]}

  , {"func": ["emitStrChar", "c"], "=":
    {"casec": "c", "of":
      [[{"str": "\""}, ["emitBackslashChar", "c"]],
       [{"str": "\\"}, ["emitBackslashChar", "c"]],
       [{"str": "\b"}, ["emitBackslashChar", {"str": "b"}]],
       [{"str": "\f"}, ["emitBackslashChar", {"str": "f"}]],
       [{"str": "\n"}, ["emitBackslashChar", {"str": "n"}]],
       [{"str": "\r"}, ["emitBackslashChar", {"str": "r"}]],
       [{"str": "\t"}, ["emitBackslashChar", {"str": "t"}]],
       ["_", {"cased": ["printableAscii", "c"], "of":
          [["B.True", ["Prim.IO.putChar", "c"]],
           ["B.False", ["emitUnicodeEscape", "c"]]]}]]}}

  , {"func": ["printableAscii", "c"], "=":
    ["charBetween", {"str": "\u0020"}, {"str": "\u007e"}, "c"]}

  , {"func": ["emitBackslashChar", "c"], "=":
    ["ioThen", ["Prim.IO.putChar", {"str": "\\"}],
               ["Prim.IO.putChar", "c"]]}

  , {"func": ["emitUnicodeEscape", "c"], "=":
    ["ioThen", ["Prim.IO.putChar", {"str": "\\"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "u"}],
               ["putStr", ["hex4", ["Prim.Char.ord", "c"]]]]]}

  , {"func": ["hex4", "n"], "=":
    ["L.map", "hex1", ["L.reverse", ["hexits", 4, "n"]]]}

  , {"func": ["hex1", "n"], "=":
    {"casei": "n", "of":
      [[0, {"str": "0"}],
       [1, {"str": "1"}],
       [2, {"str": "2"}],
       [3, {"str": "3"}],
       [4, {"str": "4"}],
       [5, {"str": "5"}],
       [6, {"str": "6"}],
       [7, {"str": "7"}],
       [8, {"str": "8"}],
       [9, {"str": "9"}],
       [10, {"str": "A"}],
       [11, {"str": "B"}],
       [12, {"str": "C"}],
       [13, {"str": "D"}],
       [14, {"str": "E"}],
       [15, {"str": "F"}],
       ["_", {"str": "?"}]]}}

  , {"func": ["hexits", "d", "n"], "=":
    {"casei": "d", "of":
      [[0, "L.Nil"],
       ["_",
          ["L.Cons",
            ["Prim.Int.rem", "n", 16],
            ["hexits", ["Prim.Int.add", -1, "d"],
                       ["Prim.Int.quot", "n", 16]]]]]}}

  , {"func": ["emitDecls", "decls"], "=":
    ["ioThen", ["Prim.IO.putChar", {"str": "{"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
    ["ioThen", ["Prim.IO.putChar", {"str": "d"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "e"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "c"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "l"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "a"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "r"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "a"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "t"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "i"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "o"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "n"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "s"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
    ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
    ["ioThen", ["emitArray", ["L.map", "emitDecl", "decls"]],
               ["Prim.IO.putChar", {"str": "}"}]]]]]]]]]]]]]]]]]]}

  , {"func": ["emitDecl", "decl"], "=":
    {"cased": "decl", "of":
      [["DataDecl", "name", "condecls",
          ["ioThen", ["Prim.IO.putChar", {"str": "{"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": "d"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "a"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "t"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "a"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
          ["ioThen", ["emitStr", "name"],
          ["ioThen", ["Prim.IO.putChar", {"str": ","}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": "="}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
          ["ioThen", ["emitArray", ["L.map", "emitConDecl", "condecls"]],
                     ["Prim.IO.putChar", {"str": "}"}]]]]]]]]]]]]]]]]],
       ["FuncDecl", "name", "argnames", "expr",
          ["ioThen", ["Prim.IO.putChar", {"str": "{"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": "f"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "u"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "n"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "c"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
          ["ioThen", ["emitArray", ["L.map", "emitStr",
            ["L.Cons", "name", "argnames"]]],
          ["ioThen", ["Prim.IO.putChar", {"str": ","}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": "="}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
          ["ioThen", ["emitExpr", "expr"],
                     ["Prim.IO.putChar", {"str": "}"}]]]]]]]]]]]]]]]]]]}}

  , {"func": ["emitConDecl", "decl"], "=":
    {"cased": "decl", "of":
      [["ConDecl", "name", "arity",
          ["ioThen", ["Prim.IO.putChar", {"str": "["}],
          ["ioThen", ["emitStr", "name"],
          ["ioThen", ["Prim.IO.putChar", {"str": ","}],
          ["ioThen", ["emitInt", "arity"],
                     ["Prim.IO.putChar", {"str": "]"}]]]]]]]}}

  , {"func": ["emitExpr", "expr"], "=":
    {"cased": "expr", "of":
      [["LetExp", "bindings", "subexpr",
          ["ioThen", ["Prim.IO.putChar", {"str": "{"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": "l"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "e"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "t"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
          ["ioThen", ["emitArray", ["L.map", "emitBinding", "bindings"]],
          ["ioThen", ["Prim.IO.putChar", {"str": ","}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": "i"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "n"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
          ["ioThen", ["emitExpr", "subexpr"],
                     ["Prim.IO.putChar", {"str": "}"}]]]]]]]]]]]]]]]]],
       ["CasedExp", "evaluand", "dalts",
          ["emitCaseExp", {"str": "d"}, "emitDAlt", "evaluand", "dalts"]],
       ["CaseiExp", "evaluand", "ialts",
          ["emitCaseExp", {"str": "i"}, "emitIAlt", "evaluand", "ialts"]],
       ["CasecExp", "evaluand", "calts",
          ["emitCaseExp", {"str": "c"}, "emitCAlt", "evaluand", "calts"]],
       ["FExp", "aexps",
          {"casei": ["L.length", "aexps"], "of":
            [[1, ["mapM_", "emitAExp", "aexps"]],
             ["_", ["emitArray", ["L.map", "emitAExp", "aexps"]]]]}]]}}

  , {"func": ["emitBinding", "binding"], "=":
    {"cased": "binding", "of":
      [["Binding", "var", "expr",
        ["emitArray",
          ["L.Cons", ["emitStr", "var"],
          ["L.Cons", ["emitExpr", "expr"],
            "L.Nil"]]]]]}}

  , {"func": ["emitCaseExp", "suffix", "emitAlt", "evaluand", "alts"], "=":
      ["ioThen", ["Prim.IO.putChar", {"str": "{"}],
      ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
      ["ioThen", ["Prim.IO.putChar", {"str": "c"}],
      ["ioThen", ["Prim.IO.putChar", {"str": "a"}],
      ["ioThen", ["Prim.IO.putChar", {"str": "s"}],
      ["ioThen", ["Prim.IO.putChar", {"str": "e"}],
      ["ioThen", ["Prim.IO.putChar", "suffix"],
      ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
      ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
      ["ioThen", ["emitExpr", "evaluand"],
      ["ioThen", ["Prim.IO.putChar", {"str": ","}],
      ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
      ["ioThen", ["Prim.IO.putChar", {"str": "o"}],
      ["ioThen", ["Prim.IO.putChar", {"str": "f"}],
      ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
      ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
      ["ioThen", ["emitArray", ["L.map", "emitAlt", "alts"]],
                 ["Prim.IO.putChar", {"str": "}"}]]]]]]]]]]]]]]]]]]}

  , {"func": ["emitDAlt", "dalt"], "=":
    {"cased": "dalt", "of":
      [["DAlt", "con", "vars", "expr",
          ["emitArray",
            ["L.Cons", ["emitStr", "con"],
              ["L.append",
                ["L.map", "emitStr", "vars"],
                ["L.Cons", ["emitExpr", "expr"], "L.Nil"]]]]]]}}

  , {"func": ["emitIAlt", "ialt"], "=":
    {"cased": "ialt", "of":
      [["IAltInt", "n", "expr",
          ["emitArray",
            ["L.Cons", ["emitInt", "n"],
            ["L.Cons", ["emitExpr", "expr"],
              "L.Nil"]]]],
       ["IAltVar", "var", "expr",
          ["emitArray",
            ["L.Cons", ["emitStr", "var"],
            ["L.Cons", ["emitExpr", "expr"],
              "L.Nil"]]]]]}}

  , {"func": ["emitCAlt", "calt"], "=":
    {"cased": "calt", "of":
      [["CAltChar", "c", "expr",
          ["emitArray",
            ["L.Cons", ["emitChar", "c"],
            ["L.Cons", ["emitExpr", "expr"],
              "L.Nil"]]]],
       ["CAltVar", "var", "expr",
          ["emitArray",
            ["L.Cons", ["emitStr", "var"],
            ["L.Cons", ["emitExpr", "expr"],
              "L.Nil"]]]]]}}

  , {"func": ["emitAExp", "aexpr"], "=":
    {"cased": "aexpr", "of":
      [["AChar", "c",
          ["ioThen", ["Prim.IO.putChar", {"str": "{"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": "s"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "t"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "r"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
          ["ioThen", ["emitStrChar", "c"],
          ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
                     ["Prim.IO.putChar", {"str": "}"}]]]]]]]]]]]],
       ["AInt", "n", ["emitInt", "n"]],
       ["AVar", "s", ["emitStr", "s"]],
       ["ACon", "s", ["emitStr", "s"]],
       ["ASub", "subexpr", ["emitExpr", "subexpr"]]]}}

  , {"func": ["emitInt", "n"], "=":
    ["putStr", ["Lolo.Digits.showInt", "n"]]}

  , {"func": ["emitChar", "c"], "=":
    ["ioThen", ["Prim.IO.putChar", {"str": "{"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
    ["ioThen", ["Prim.IO.putChar", {"str": "s"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "t"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "r"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
    ["ioThen", ["Prim.IO.putChar", {"str": ":"}],
    ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
    ["ioThen", ["Prim.IO.putChar", "c"],
    ["ioThen", ["Prim.IO.putChar", {"str": "\""}],
               ["Prim.IO.putChar", {"str": "}"}]]]]]]]]]]]}

  , {"comment":



    "### Entry point ###"



    }

  , {"func": ["checkParseResult", "result"], "=":
    {"cased": "result", "of":
      [["Left", "c", ["Prim.IO.putChar", "c"]],
       ["Right", "decls", ["emitDecls", "decls"]]]}}

  , {"func": ["main"], "=":
    ["Prim.IO.bind", "parseStdin", "checkParseResult"]}

  ]
}
